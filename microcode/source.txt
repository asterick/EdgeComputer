/*
 * privileged
 */

macro (next_operation) {
	mdr.l = [A3], A3.l = A3.l + 1; if (@c) { A3.h = A3.h + 1; }
}

macro (push) {
	[A2] = mdr.h, A2.l = A2.l + 1; if (@c) { A2.h = A2.h + 1; }
	[A2] = mdr.l, A2.l = A2.l + 1; if (@c) { A2.h = A2.h + 1; }
}

macro (priv_pop) {
	privileged,   A2.l = A2.l - 1; if (@c) { A2.h = A2.h + 1; }
	mdr.l = [A2], A2.l = A2.l - 1; if (@c) { A2.h = A2.h + 1; }
	mdr.h = [A2];
}

macro (pop) {
	              A2.l = A2.l - 1; if (@c) { A2.h = A2.h + 1; }
	mdr.l = [A2], A2.l = A2.l - 1; if (@c) { A2.h = A2.h + 1; }
	mdr.h = [A2];
}

// Default operation: No operation
default { #next_operation; }

// Reset / ISR
opcode(0x00) {
	// Preserve PC
	mdr = A3.L; # push;
	mdr = A3.H; # push;
	mdr = MSR; # push;

	MSR = MSR or 0x0200; // Supervisor mode
	A3.L = R5 and 0xFF;
	A3.H = R5 nand 0xFF;
	A3.L = A3.L + IRQ_VECTOR;

	# next_operation;
}

// Return from interrupt
opcode(0x01) {
	#priv_pop; MSR = mdr;
	#pop; A3.H = mdr;
	#pop; A3.L = mdr;

	# next_operation;
}

// Return
opcode(0x02) {
	#pop; A3.H = mdr;
	#pop; A3.L = mdr;

	# next_operation;
}

// Halt (Don't change contents of MDR so the opcode just wraps)
opcode(0x03) { ; }

