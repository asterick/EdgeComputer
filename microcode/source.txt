/*
 *
 *
 */

macro (next_operation) {
	mdr.l = [A4], A4.l = A4.l + 1; if (@c) { A4.h = A4.h + 1; }
}

macro (push) {
	A3.l = A3.l + 1; if (@c) { A3.h = A3.h + 1; }
	[A4] = mdr.l;
}
macro (pop) {
	mdr.l = [A3];
	A3.l = A3.l + 1; if (@c) { A3.h = A3.h + 1; }
}

/* No op */
opcode(0x00) {
	// Fetch next instruction
	# next_operation;
}

opcode(0x01) {
	priviledged, (tlb.index) = r1;
	# next_operation;
}

opcode(0x02) {
	priviledged, (tlb.bank) = r1;
	# next_operation;
}

opcode(0x03) {
	priviledged, (tlb.flags) = r1;
	# next_operation;
}

// Fast move
opcode(0x04) {
	loop:

	mdr.l = [A1], A1.l = A1.l + 1; if (@c) { a1.h = a1.h + 1; }
	[A2] = mdr.h, A2.l = A2.l + 1; if (@c) { a2.h = a2.h + 1; }
	
	// Decrement counter
	(flags, r1) = r1 - 1; if (~c) { goto loop; }

	# next_operation;
}

// Long branch on carry
opcode(0x05) {
	mdr.l = [A4], A4.l = A4.l + 1; if (@c) { A4.h = A4.h + 1; }
	mdr.h = [A4], A4.l = A4.l + 1; if (@c) { A4.h = A4.h + 1; }
	if (c) { A4.l = mdr; }
	mdr.l = [A4], A4.l = A4.l + 1; if (@c) { A4.h = A4.h + 1; }
	if (c) { A4.h = mdr; }
	# next_operation;
}

opcode(0x06) {
	msr = msr and 0;
}

// ISR
opcode(0xFF) {
	MDR = MSR;  # push;
	MDR = A4.l; # push;
	MDR = A4.h; # push;

	A4.L = swap R6; 
	A4.L = A4.L and 255;
	(A4.L, flags) = A4.L + IRQ_VECTOR;
	A4.H = R6 + 0 + C;

	# next_operation;
}
